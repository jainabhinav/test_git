{"initCode":"","code":"udf({\n    (input: Seq[Row] ) =>\n    import _root_.io.prophecy.abinitio.ScalaFunctions._\n    import _root_.io.prophecy.libs.AbinitioDMLs._\n    val outputRows = scala.collection.mutable.ArrayBuffer[Row]()\n      var SEQFILE_CHUNK_SIZE = 0\n  var ALLOW_EMPTY_INPUT  = 0\n\n  def output_read_spec(filepath: String, info: file_information_type, in_record: Row) = {\n    var start_offset        = 0L\n    var end_offset          = 0L\n    var file_size_remaining = convertToLong(info.size)\n    var address             = Row(null, null, null)\n    var block_size = convertToInt(\n      if (\n        (try info.block_size\n        catch {\n          case error: Throwable => null\n        }) == null\n      )\n        0\n      else\n        info.block_size\n    )\n    if (convertToBoolean(convertToInt(block_size) == 0))\n      _print_error(((\"block_size is 0 in Find Files and Read Blocks \" + _string_representation(info)) + \"\"\"\n\"\"\").toString)\n    var idx = 0\n\n    while (convertToBoolean(compareTo(idx, info.host.length) < 0)) {\n      var chunk_number = 0L\n      start_offset = convertToLong(_math_min(idx * block_size,     info.size))\n      end_offset = convertToLong(_math_min((idx + 1) * block_size, info.size))\n      if (convertToBoolean(compareTo(convertToLong(_string_lrtrim(SEQFILE_CHUNK_SIZE.toString)), 0) > 0)) {\n\n        while (convertToBoolean(compareTo(start_offset, end_offset) < 0)) {\n          var size_this_time =\n            if (convertToBoolean(compareTo(end_offset - start_offset, SEQFILE_CHUNK_SIZE) < 0))\n              end_offset - start_offset\n            else\n              SEQFILE_CHUNK_SIZE\n          address = Row(if (convertToBoolean(compareTo(end_offset, start_offset) > 0))\n                          start_offset\n                        else\n                          0,\n                        size_this_time,\n                        0\n          )\n          outputRows.append(\n            Row(\n              filepath.toString,\n              Row(convertToLong(address.get(0)), convertToInt(address.get(1)), convertToInt(address.get(2))),\n              (info.host).array(convertToInt(idx)),\n              Row((in_record.get(0)).toString),\n              convertToInt(chunk_number)\n            )\n          )\n          start_offset = convertToLong(start_offset + size_this_time)\n          chunk_number = convertToLong(chunk_number + 1)\n        }\n\n      } else {\n        address = Row(if (convertToBoolean(compareTo(end_offset, start_offset) > 0))\n                        start_offset\n                      else\n                        0,\n                      end_offset - start_offset,\n                      0\n        )\n        outputRows.append(\n          Row(\n            filepath.toString,\n            Row(convertToLong(address.get(0)), convertToInt(address.get(1)), convertToInt(address.get(2))),\n            (info.host).array(convertToInt(idx)),\n            Row((in_record.get(0)).toString),\n            convertToInt(0)\n          )\n        )\n      }\n      idx = convertToInt(idx + 1)\n    }\n\n    0\n  }\n\n  def traverse_directory(current_directory: String, in_record: Row): Int = {\n    var dirlist = _directory_listing(current_directory.toString, \"[!._]*\")\n    if (convertToBoolean(convertToLong(_string_lrtrim(ALLOW_EMPTY_INPUT.toString)) == 0)) {\n      if (convertToBoolean(compareTo(dirlist.length, 1) < 0))\n        _print_error((current_directory + \" has no files.\").toString)\n    }\n    dirlist.zipWithIndex.map {\n      case (_shortpath, shortpathIndex) =>\n        var shortpath = _shortpath\n        var fullpath  = (current_directory + \"/\") + shortpath\n        var info      = _file_information(fullpath.toString)\n        if (convertToBoolean(info.found) && convertToBoolean((info.file_type).toString == \"DIR \"))\n          traverse_directory(fullpath, in_record)\n        else if (convertToBoolean(_ends_with(shortpath.toString, \"\")))\n          output_read_spec(fullpath,                             info, in_record)\n    }.toArray\n    null\n    0\n  }\n\n  def process(input: Seq[Row]) = {\n    var readRecordInstance = RecordIterator.getInstance(input)\n    var have_data          = 1\n\n    while (convertToBoolean(have_data)) {\n      var in_record = readRecordInstance.readRecord\n      var starting_path = (if (\n                             (try in_record.getAs[String](\"_AB_read_hdfs_files_starting_path_\")\n                             catch {\n                               case error: Throwable => null\n                             }) == null\n                           )\n                             \"\"\n                           else\n                             in_record.getAs[String](\"_AB_read_hdfs_files_starting_path_\")).toString\n      if (convertToBoolean(starting_path.toString == \"\"))\n        have_data = convertToInt(0)\n      else {\n        var info = _file_information(starting_path.toString)\n        if (convertToBoolean(info.found) && convertToBoolean((info.file_type).toString == \"DIR \"))\n          traverse_directory(starting_path, in_record)\n        else if (convertToBoolean(info.found) && convertToBoolean((info.file_type).toString == \"HDFS\"))\n          output_read_spec(starting_path, info, in_record)\n        else _print_error((starting_path + \" not found.\").toString)\n      }\n    }\n\n    null\n    0\n  }\n\n\n    process(input)\n    outputRows\n    },\n    ArrayType( StructType(\n      List(\n      StructField(\"_AB_read_hdfs_files_filename\", StringType, false),StructField(\"_AB_read_hdfs_files_address\",  StructType(\n      List(\n      StructField(\"file_offset\", LongType, false),StructField(\"compr_size\", IntegerType, false),StructField(\"byte_offset\", IntegerType, false)\n      )\n    ), false),StructField(\"_AB_read_hdfs_files_hosts\", ArrayType(StringType), false),StructField(\"_AB_read_hdfs_files_input_record\",  StructType(\n      List(\n      StructField(\"_AB_read_hdfs_files_starting_path_\", StringType, false)\n      )\n    ), false),StructField(\"sequence_number\", IntegerType, false)\n      )\n    ))\n  )\n"}